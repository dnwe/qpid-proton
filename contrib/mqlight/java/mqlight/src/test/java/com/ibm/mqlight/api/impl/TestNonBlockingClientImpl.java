/*
 *   <copyright 
 *   notice="oco-source" 
 *   pids="5725-P60" 
 *   years="2015" 
 *   crc="1438874957" > 
 *   IBM Confidential 
 *    
 *   OCO Source Materials 
 *    
 *   5724-H72
 *    
 *   (C) Copyright IBM Corp. 2015
 *    
 *   The source code for the program is not published 
 *   or otherwise divested of its trade secrets, 
 *   irrespective of what has been deposited with the 
 *   U.S. Copyright Office. 
 *   </copyright> 
 */

package com.ibm.mqlight.api.impl;

import static org.junit.Assert.*;

import java.math.BigDecimal;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;

import junit.framework.AssertionFailedError;

import org.junit.Test;

import com.ibm.mqlight.api.ClientOptions;
import com.ibm.mqlight.api.ClientState;
import com.ibm.mqlight.api.Delivery;
import com.ibm.mqlight.api.DestinationAdapter;
import com.ibm.mqlight.api.DestinationListener;
import com.ibm.mqlight.api.MalformedDelivery;
import com.ibm.mqlight.api.NonBlockingClient;
import com.ibm.mqlight.api.NonBlockingClientListener;
import com.ibm.mqlight.api.Promise;
import com.ibm.mqlight.api.QOS;
import com.ibm.mqlight.api.SendOptions;
import com.ibm.mqlight.api.callback.CallbackService;
import com.ibm.mqlight.api.endpoint.Endpoint;
import com.ibm.mqlight.api.endpoint.EndpointPromise;
import com.ibm.mqlight.api.endpoint.EndpointService;
import com.ibm.mqlight.api.impl.callback.SameThreadCallbackService;
import com.ibm.mqlight.api.impl.engine.DeliveryRequest;
import com.ibm.mqlight.api.timer.TimerService;

public class TestNonBlockingClientImpl {

    private class StubEndpointService implements EndpointService {
        @Override public void lookup(EndpointPromise promise) {}
        @Override public void onSuccess(Endpoint endpoint) {}
    }
    
    private class StubCallbackService implements CallbackService {
        @Override public void run(Runnable runnable, Object orderingCtx, Promise<Void> promise) {}
    }
    
    private class StubTimerService implements TimerService {
        @Override public void schedule(long delay, Promise<Void> promise) {}
        @Override public void cancel(Promise<Void> promise) {}
    }
    
//    private class StubDestinationListener<T> implements DestinationListener<T> {
//        @Override public void onMessage(NonBlockingClient client, T context, Delivery delivery) {}
//        @Override public void onMalformed(NonBlockingClient client, T context, MalformedDelivery delivery) {}
//        @Override public void onUnsubscribed(NonBlockingClient client, T context, String topicPattern, String share) {}
//    }

    @Test public void autoGeneratedClientId() {
        StubEndpointService endpointService = new StubEndpointService();
        StubCallbackService callbackService = new StubCallbackService();
        MockComponent component = new MockComponent();
        StubTimerService timerService = new StubTimerService();
        NonBlockingClientImpl client = new NonBlockingClientImpl(endpointService, callbackService, component, timerService, ClientOptions.builder().build(), null, null);
        assertTrue("Expected auto generated client ID to start with string 'AUTO_'", client.getId().startsWith("AUTO_"));
    }
    
    @Test public void endpointServiceReportsFatalFailure() {
        StubEndpointService endpointService = new StubEndpointService() {
            @Override public void lookup(EndpointPromise promise) {
                promise.setFailure(new Exception());
            }
        };
        StubCallbackService callbackService = new StubCallbackService();
        MockComponent component = new MockComponent();
        StubTimerService timerService = new StubTimerService();
        NonBlockingClientImpl client = new NonBlockingClientImpl(endpointService, callbackService, component, timerService, ClientOptions.builder().build(), null, null);
        assertEquals("Client should have transitioned into stopping state, ", ClientState.STOPPING, client.getState());
    }
    
    @Test
    public void nullValuesIntoConstructor() {
        StubEndpointService endpointService = new StubEndpointService();
        StubCallbackService callbackService = new StubCallbackService();
        MockComponent component = new MockComponent();
        StubTimerService timerService = new StubTimerService();

        // Specifying null options, listener and context object should not throw an exception
        new NonBlockingClientImpl(endpointService, callbackService, component, timerService, null, null, null);

        // Specifying a null endpoint service should throw an exception
        try {
            new NonBlockingClientImpl(null, callbackService, component, timerService, null, null, null);
            throw new AssertionFailedError("Null endpoint service should have thrown an exception");
        } catch(IllegalArgumentException e) {
            // Expected
        }
        
        // Specifying a null callback service should throw an exception
        try {
            new NonBlockingClientImpl(endpointService, null, component, timerService, null, null, null);
            throw new AssertionFailedError("Null callback service should have thrown an exception");
        } catch(IllegalArgumentException e) {
            // Expected
        }
        
        // Specifying a null timer service should throw an exception
        try {
            new NonBlockingClientImpl(endpointService, callbackService, component, null, null, null, null);
            throw new AssertionFailedError("Null timer service should have thrown an exception");
        } catch(IllegalArgumentException e) {
            // Expected
        }
    }
    
    @Test
    public void nullValuesIntoSend() {
        StubEndpointService endpointService = new StubEndpointService();
        StubCallbackService callbackService = new StubCallbackService();
        MockComponent component = new MockComponent();
        StubTimerService timerService = new StubTimerService();
        NonBlockingClientImpl client = new NonBlockingClientImpl(endpointService, callbackService, component, timerService, null, null, null);
        
        // Null properties, send options, listener and context object should be okay...
        client.send("topic", "data", null, null, null, null);
        client.send("topic", ByteBuffer.allocate(1), null, null, null, null);
        
        // Null topic should throw an exception
        try {
            client.send(null, "data", null, null, null, null);
            throw new AssertionFailedError("Null topic (send String) should have thrown an exception");
        } catch(IllegalArgumentException e) {
            // Expected
        }
        try {
            client.send(null, ByteBuffer.allocate(1), null, null, null, null);
            throw new AssertionFailedError("Null topic (send ByteBuffer) should have thrown an exception");
        } catch(IllegalArgumentException e) {
            // Expected
        }
        
        // Null data should throw an exception
        // Null topic should throw an exception
        try {
            client.send("topic", (String)null, null, null, null, null);
            throw new AssertionFailedError("Null data (send String) should have thrown an exception");
        } catch(IllegalArgumentException e) {
            // Expected
        }
        try {
            client.send("topic", (ByteBuffer)null, null, null, null, null);
            throw new AssertionFailedError("Null data (send ByteBuffer) should have thrown an exception");
        } catch(IllegalArgumentException e) {
            // Expected
        }
    }
    
    @Test
    public void messageTtlValues() {
        SendOptions.builder().setTtl(1).build();
        
        try {
            SendOptions.builder().setTtl(0).build();
            throw new AssertionFailedError("Zero TTL should have thrown an exception");
        } catch(IllegalArgumentException e) {
            // Expected
        }
        
        try {
            SendOptions.builder().setTtl(-1).build();
            throw new AssertionFailedError("-1 TTL should have thrown an exception");
        } catch(IllegalArgumentException e) {
            // Expected
        }
    }

    @Test
    public void nullValuesIntoSubscribe() {
        StubEndpointService endpointService = new StubEndpointService();
        StubCallbackService callbackService = new StubCallbackService();
        MockComponent component = new MockComponent();
        StubTimerService timerService = new StubTimerService();
        NonBlockingClientImpl client = new NonBlockingClientImpl(endpointService, callbackService, component, timerService, null, null, null);
        
        // Null subscription options, completion listener, and context should be fine...
        client.subscribe("topicPattern", null, new DestinationAdapter<Object>(){}, null, null);
        
        // Null topic pattern should throw an exception
        try {
            client.subscribe(null, null, new DestinationAdapter<Object>(){}, null, null);
            throw new AssertionFailedError("Null topic pattern should have thrown an exception");
        } catch(IllegalArgumentException e) {
            // Expected
        }
        
        // Null destination listener should throw an exception
        try {
            client.subscribe("topicPattern", null, null, null, null);
            throw new AssertionFailedError("Null destination listener should have thrown an exception");
        } catch(IllegalArgumentException e) {
            // Expected
        }
    }
    
    @Test
    public void nullValuesIntoUnsubscribe() {
        StubEndpointService endpointService = new StubEndpointService();
        StubCallbackService callbackService = new StubCallbackService();
        MockComponent component = new MockComponent();
        StubTimerService timerService = new StubTimerService();
        NonBlockingClientImpl client = new NonBlockingClientImpl(endpointService, callbackService, component, timerService, null, null, null);
        
        // Null share, listener and context object should be fine...
        client.unsubscribe("topicPattern", null, 0, null, null);
        client.unsubscribe("topicPattern", null, null, null);
        
        // Null topic pattern should throw an exception
        try {
            client.unsubscribe(null, null, 0, null, null);
            throw new AssertionFailedError("Null topic pattern should have thrown an exception (1)");
        } catch(IllegalArgumentException e) {
            // Expected
        }
        try {
            client.unsubscribe(null, null, null, null);
            throw new AssertionFailedError("Null topic pattern should have thrown an exception (2)");
        } catch(IllegalArgumentException e) {
            // Expected
        }
    }
    
    @Test
    public void nonzeroTtlIntoUnsubscribe() {
        StubEndpointService endpointService = new StubEndpointService();
        StubCallbackService callbackService = new StubCallbackService();
        MockComponent component = new MockComponent();
        StubTimerService timerService = new StubTimerService();
        NonBlockingClientImpl client = new NonBlockingClientImpl(endpointService, callbackService, component, timerService, null, null, null);
        
        try {
            client.unsubscribe("topicPattern", null, 7, null, null);
            throw new AssertionFailedError("Non-zero ttl should have thrown an exception");
        } catch(IllegalArgumentException e) {
            // Expected
        }
    }
    
    @Test
    public void topicEncoding() {
        String[][] testData = new String[][] {
            {"", "amqp:///"},
            {"/", "amqp:////"},
            {"/kittens", "amqp:////kittens"},
            {"kittens", "amqp:///kittens"},
            {"kittens/puppies", "amqp:///kittens/puppies"},
            {"kittens/puppies/", "amqp:///kittens/puppies/"},
            {"/kittens/puppies", "amqp:////kittens/puppies"},
            {"/kittens/puppies/", "amqp:////kittens/puppies/"},
            {"&", "amqp:///%26"},
            {"/&", "amqp:////%26"},
            {"&/", "amqp:///%26/"},
            {"/kittens&", "amqp:////kittens%26"},
            {"/kit&tens", "amqp:////kit%26tens"},
            {"/&kittens", "amqp:////%26kittens"},
            {"&/kittens", "amqp:///%26/kittens"},
            {"&/&kit&tens&/&pup&pies&/&", "amqp:///%26/%26kit%26tens%26/%26pup%26pies%26/%26"},
        };
        for (int i = 0; i < testData.length; ++i) {
            assertEquals("test case #"+i, testData[i][1], NonBlockingClientImpl.encodeTopic(testData[i][0]));
        }
    }
    
    @Test
    public void roundtripMessageProperties() {
        StubEndpointService endpointService = new StubEndpointService();
        StubCallbackService callbackService = new StubCallbackService();
        MockComponent component = new MockComponent();
        StubTimerService timerService = new StubTimerService();
        class MockClient extends NonBlockingClientImpl {
            private LinkedList<Message> messages = new LinkedList<>();
            protected <T> MockClient(EndpointService endpointService,
                    CallbackService callbackService, Component engine,
                    TimerService timerService, ClientOptions options,
                    NonBlockingClientListener<T> listener, T context) {
                super(endpointService, callbackService, engine, timerService, options,
                        listener, context);
            }
            @Override
            public void tell(Message message, Component self) {
                messages.addLast(message);
            }
            protected java.util.List<Message> getMessages() {
                return messages;
            }
        }
        class TestDestinationListener implements DestinationListener<Void> {
            protected Map<String, Object> properties = null;
            @Override
            public void onMessage(NonBlockingClient client, Void context, Delivery delivery) {
                properties = delivery.getProperties();
            }
            @Override
            public void onMalformed(NonBlockingClient client, Void context, MalformedDelivery delivery) {
            }
            @Override
            public void onUnsubscribed(NonBlockingClient client, Void context, String topicPattern, String share) {
            }
        }
        
        MockClient client = new MockClient(endpointService, callbackService, component, timerService, null, null, null);
        HashMap<String, Object> props = new HashMap<>();
        //boolean.class, byte.class, short.class, int.class, long.class, float.class, double.class, byte[].class, String.class
        props.put("boolean", true);
        props.put("byte", (byte)0x01);
        props.put("short", (short)123);
        props.put("int", (int)4567);
        props.put("long", (long)121723);
        props.put("float", (float)0.1234);
        props.put("double", (double)543.1234);
        props.put("byte[]", new byte[]{1,2,3,4});
        props.put("string", "this is a string");
       
        client.send("/kittens", "data", props);

        assertEquals("Expected a single message to have been sent to the mock engine component", 1, client.getMessages().size());
        InternalSend<?> send = (InternalSend<?>)client.getMessages().get(0);
        byte[] data = new byte[send.length];
        System.arraycopy(send.data, 0, data, 0, send.length);

        DeliveryRequest dr = new DeliveryRequest(data, QOS.AT_MOST_ONCE, "/kittens", null, null);
        TestDestinationListener destinationListener = new TestDestinationListener();
        DestinationListenerWrapper<Void> wrapper = new DestinationListenerWrapper<>(client, destinationListener, null);
        wrapper.onDelivery(new SameThreadCallbackService(), dr, QOS.AT_MOST_ONCE, false);
        
        assertNotNull("Expected onMessage to have been called with message properties", destinationListener.properties);
        assertEquals("Expected all message properties to have been round-tripped", props.size(), destinationListener.properties.size());
        Map<String, Object> actualProperties = destinationListener.properties;
        for (Map.Entry<String, Object> expectedProperty : props.entrySet()) {
            assertTrue("Round-tripped properties should have contained key: "+expectedProperty.getKey(), actualProperties.containsKey(expectedProperty.getKey()));
            if (expectedProperty.getValue() instanceof byte[]) {
                assertTrue("Round-tripped byte array should match for key: "+expectedProperty.getKey(), 
                        Arrays.equals((byte[])expectedProperty.getValue(), (byte[])actualProperties.get(expectedProperty.getKey())));
            } else {
                assertEquals("Ronnd-tripped value should match for key: "+expectedProperty.getKey(), expectedProperty.getValue(), actualProperties.get(expectedProperty.getKey()));
            }
        }
    }
    
    @Test
    public void validPropertyValues() {
        assertTrue("null", NonBlockingClientImpl.isValidPropertyValue(null));
        assertTrue("boolean", NonBlockingClientImpl.isValidPropertyValue(false));
        assertTrue("byte", NonBlockingClientImpl.isValidPropertyValue((byte)3));
        assertTrue("short", NonBlockingClientImpl.isValidPropertyValue((short)3));
        assertTrue("int", NonBlockingClientImpl.isValidPropertyValue((int)3));
        assertTrue("long", NonBlockingClientImpl.isValidPropertyValue((long)3L));
        assertTrue("float", NonBlockingClientImpl.isValidPropertyValue((float)3.0));
        assertTrue("double", NonBlockingClientImpl.isValidPropertyValue((double)3.0));
        assertTrue("byte[]", NonBlockingClientImpl.isValidPropertyValue(new byte[0]));
        assertTrue("string", NonBlockingClientImpl.isValidPropertyValue("hello"));
        
        assertFalse("Object", NonBlockingClientImpl.isValidPropertyValue(new Object()));
        assertFalse("char", NonBlockingClientImpl.isValidPropertyValue('c'));
        assertFalse("BigDecimal", NonBlockingClientImpl.isValidPropertyValue(new BigDecimal(3)));
    }
}
