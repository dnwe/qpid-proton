import unittest
import re
import inspect
import os
from mock import Mock, patch
import mqlight
import mqlightexceptions as mqlexc

class TestCreateClient(unittest.TestCase):
    """
    Unit tests for Client()
    """

    def test_golden_path(self):
        """
        Test the folden path through using a client
        """
        client_id = 'test_golden_path'
        service = 'amqp://host:1234'
        client = mqlight.Client(service, client_id)
        self.assertIn(client.get_state(), (mqlight.STARTING, mqlight.STARTED))
        self.assertEqual(client.get_id(), client_id)
        def started(value):
            self.assertEqual(value, None)
            self.assertEqual(client.get_state(), mqlight.STARTED)
            self.assertEqual(client.get_service(), service)
            client.stop()
        client.add_listener(mqlight.STARTED, started)

    def test_service_not_a_string(self):
        """
        Test that a service name must be a string
        """
        with self.assertRaises(TypeError) as exc:
            mqlight.Client(1234)
        self.assertEqual(
            str(exc.exception),
            'service must be a str or list type')

    def test_create_client_must_have_a_value(self):
        """
        Test that passing no value to create_client is not valid
        """
        with self.assertRaises(TypeError):
            mqlight.Client()

    def test_create_client_callback_must_be_function(self):
        """
        Test that only a function() is accepted as the callback argument
        """
        with self.assertRaises(TypeError):
            mqlight.Client('amqp://host:1234', callback=1)

    def test_create_client_must_have_service_value(self):
        """
        Test that omitting the 'service' property from createClient causes an
        error
        """
        with self.assertRaises(TypeError):
            mqlight.Client(
                client_id='test_create_client_must_have_service_value')

    def test_id_types_values(self):
        """
        Test a range of types / values for client IDs
        """
        data = [
            { 'data': 1234, 'valid': True },
            { 'data': None, 'valid': True },
            { 'data': True, 'valid': True },
            { 'data': 'abc1234', 'valid': True },
            { 'data': ':1234', 'valid': False },
            { 'data': '1234:', 'valid': False },
            { 'data': '12:34', 'valid': False },
            { 'data': '%./_', 'valid': True },
            { 'data': '&.\_', 'valid': False }
        ]
        for i in data:
            try:
                client = mqlight.Client('amqp://localhost:5672', i['data'])
                self.assertTrue(i['valid'], i['data'])
                client.stop()
            except Exception:
                self.assertFalse(i['valid'], i['data'])

    def test_id_autogenerated(self):
        """
        Test that if the 'id' property is omitted then the client id will be
        generated
        """
        client = mqlight.Client('amqp://localhost:5672')
        self.assertNotEqual(
            None,
            re.search(r'^AUTO_[a-z0-9%/._]{7}$', client.get_id()))
        client.stop()

    def test_user_password_types_values(self):
        """
        Test a range of user and password types / values
        """
        data = [
            {'user': 'abc', 'password': None, 'valid': False },
            {'user': None, 'password': 'abc', 'valid': False },
            {'user': 'abc', 'password': '123', 'valid': True },
            {'user': 1234, 'password': 'abc', 'valid': False },
            {'user': 'abc', 'password': 1234, 'valid': False },
            {
                'user': '!"$%^&*()-_=+[{]};:\'@#~|\<,>.?/',
                'password': '!"$%^&*()-_=+[{]};:\'@#~|\<,>.?/',
                'valid': True
            }
        ]
        for i in data:
            security_options = {
                'property_user': i['user'],
                'property_password': i['password']
            }
            try:
                client = mqlight.Client(
                    'amqp://localhost:5672',
                    'id',
                    security_options)
                self.assertTrue(i['valid'], i)
                client.stop()
            except Exception as exc:
                self.assertFalse(i['valid'], i)

    @unittest.expectedFailure
    def test_password_hidden(self):
        """
        Test that a clear text password isn't trivially recoverable from the
        client object
        """
        client = mqlight.Client(
            'amqp://localhost:5672',
            'id',
            { 'property_user': 'username', 'property_password': 's3cret' })
        self.assertEqual(
            None,
            re.search(
                r's3cret',
                str(inspect.getmembers(
                    client,
                    lambda a:not(inspect.isroutine(a))))))
        client.stop()

    def test_valid_uris(self):
        """
        Test that the value returned by client.get_service is a lower cased URL
        which always has a port number
        """
        data = [
            { 'uri': 'amqp://host', 'expected': 'amqp://host:5672' },
            { 'uri': 'amqps://host', 'expected': 'amqps://host:5671' },
            { 'uri': 'AmQp://HoSt', 'expected': 'amqp://host:5672' },
            { 'uri': 'aMqPs://hOsT', 'expected': 'amqps://host:5671' },
            { 'uri': 'amqp://host:1234', 'expected': 'amqp://host:1234' },
            { 'uri': 'amqps://host:4321', 'expected': 'amqps://host:4321' },
            { 'uri': 'aMqP://HoSt:1234', 'expected': 'amqp://host:1234' },
            { 'uri': 'AmQpS://hOsT:4321', 'expected': 'amqps://host:4321' }
        ]
        count = 0
        for i in data:
            count += 1
            client = mqlight.Client(i['uri'])
            def started(err):
                self.assertEqual(client.get_service(), i['expected'])
            client.add_listener(mqlight.STARTED, started)
        self.assertEqual(count, len(data))

    def test_bad_ssl_options(self):
        """
        Test that bad ssl options cause createClient to fail
        """
        data = [
            { 'ssl_trust_certificate': 1, 'ssl_verify_name': True },
            { 'ssl_trust_certificate': { 'a': 1 }, 'ssl_verify_name': True },
            { 'ssl_trust_certificate': True, 'ssl_verify_name': True },
            {
                'ssl_trust_certificate': 'ValidCertificate',
                'ssl_verify_name': 'a'
            },
            {
                'ssl_trust_certificate': 'ValidCertificate',
                'ssl_verify_name': 1
            },
            {
                'ssl_trust_certificate': 'ValidCertificate',
                'ssl_verify_name': { 'a': 1 }
            },
            {
                'ssl_trust_certificate': 'MissingCertificate',
                'ssl_verify_name': True
            },
            {
                'ssl_trust_certificate': 'dirCertificate',
                'ssl_verify_name': True
            }
        ]
        if not os.path.exists('dirCertificate'):
            os.makedirs('dirCertificate')
        for i in range(len(data)):
            print 'testing '
            print data[i]
            with self.assertRaises(Exception) as err:
                service = 'amqp://host'
                client_id = 'test_bad_ssl_options'
                security_options = data[i]
                mqlight.Client(service, client_id, security_options)
            err_type = type(err.exception)
            self.assertTrue(err_type in (TypeError, mqlexc.SecurityError, mqlexc.InvalidArgumentError), 'errtype is ' + str(err_type))
        if os.path.exists('dirCertificate'):
            os.rmdir('dirCertificate')

    def test_valid_ssl_options(self):
        """
        Test that the ssl options for valid certificates cause start to be
        successful
        """
        data = [
            {
                'ssl_trust_certificate': 'ValidCertificate',
                'ssl_verify_name': True
            },
            {
                'ssl_trust_certificate': 'ValidCertificate',
                'ssl_verify_name': True
            },
            {
                'ssl_trust_certificate': 'BadVerify',
                'ssl_verify_name': False
            }
        ]
        valid_certificate_fd = open('ValidCertificate', 'w')
        bad_verify_fd = open('BadVerify', 'w')
        self.count = 0
        def valid_ssl_test(ssl_trust_certificate, ssl_verify_name):
            service = 'amqp://host'
            client_id = 'test_valid_ssl_options'
            security_options = {
                'ssl_trust_certificate': ssl_trust_certificate,
                'ssl_verify_name': ssl_verify_name
            }
            client = mqlight.Client(service, client_id, security_options)
            def error(err):
                client.stop()
                self.assertTrue(False, 'unexpected error event: ' + str(err))
                valid_certificate_fd.close()
                os.remove('ValidCertificate')
                bad_verify_fd.close()
                os.remove('BadVerify')
            client.add_listener(mqlight.ERROR, error)
            def start(err):
                self.assertEqual(err, None)
                client.stop()
                self.count += 1
                if self.count == len(data):
                    valid_certificate_fd.close()
                    os.remove('ValidCertificate')
                    bad_verify_fd.close()
                    os.remove('BadVerify')
                else:
                    valid_ssl_test(
                        data[self.count]['ssl_trust_certificate'],
                        data[self.count]['ssl_verify_name'])

            client.start(start)

        valid_ssl_test(
            data[self.count]['ssl_trust_certificate'],
            data[self.count]['ssl_verify_name'])

    def test_invalid_ssl_options(self):
        """
        Test that the ssl options for invalid certificates cause start to fail
        """
        data = [
            {
                'ssl_trust_certificate': 'BadCertificate',
                'ssl_verify_name': True
            },
            {
                'ssl_trust_certificate': 'BadCertificate',
                'ssl_verify_name': False
            },
            {
                'ssl_trust_certificate': 'BadVerify',
                'ssl_verify_name': True
            }
        ]
        bad_certificate_fd = open('BadCertificate', 'w')
        bad_verify_fd = open('BadVerify', 'w')
        self.count = 0
        def valid_ssl_test(ssl_trust_certificate, ssl_verify_name):
            service = 'amqp://host'
            client_id = 'test_invalid_ssl_options'
            security_options = {
                'ssl_trust_certificate': ssl_trust_certificate,
                'ssl_verify_name': ssl_verify_name
            }
            client = mqlight.Client(service, client_id, security_options)
            def error(err):
                self.assertTrue(True)
                client.stop()
                self.count += 1
                if self.count == len(data):
                    bad_certificate_fd.close()
                    os.remove('BadCertificate')
                    bad_verify_fd.close()
                    os.remove('BadVerify')
                else:
                    valid_ssl_test(
                        data[self.count]['ssl_trust_certificate'],
                        data[self.count]['ssl_verify_name'])
            client.add_listener(mqlight.ERROR, error)
            def started(err):
                client.stop()
                self.assertTrue(
                    False,
                    'unexpected started event' + str(security_options))
                bad_certificate_fd.close()
                os.remove('BadCertificate')
                bad_verify_fd.close()
                os.remove('BadVerify')
            client.add_listener(mqlight.STARTED, started)

        valid_ssl_test(
            data[self.count]['ssl_trust_certificate'],
            data[self.count]['ssl_verify_name'])

if __name__ == 'main':
    unittest.main()
