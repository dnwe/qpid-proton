"""
<copyright
notice="lm-source-program"
pids="5725-P60"
years="2013,2014"
crc="3568777996" >
Licensed Materials - Property of IBM

5725-P60

(C) Copyright IBM Corp. 2013, 2014

US Government Users Restricted Rights - Use, duplication or
disclosure restricted by GSA ADP Schedule Contract with
IBM Corp.
</copyright>
"""
import unittest
import re
import inspect
import os
import mqlight
import mqlightexceptions as mqlexc

class TestCreateClient(unittest.TestCase):
    """
    Unit tests for Client()
    """

    def test_golden_path(self):
        """
        Test the folden path through using a client
        """
        client_id = 'test_golden_path'
        service = 'amqp://host:1234'
        client = mqlight.Client(service, client_id)
        self.assertIn(client.get_state(), (mqlight.STARTING, mqlight.STARTED))
        self.assertEqual(client.get_id(), client_id)
        def started(value):
            self.assertEqual(value, None)
            self.assertEqual(client.get_state(), mqlight.STARTED)
            self.assertEqual(client.get_service(), service)
            client.stop()
        client.add_listener(mqlight.STARTED, started)

    def test_service_not_a_string(self):
        """
        Test that a service name must be a string
        """
        with self.assertRaises(TypeError) as exc:
            mqlight.Client(1234)
        self.assertEqual(
            str(exc.exception),
            'service must be a str or list type')

    def test_create_client_must_have_a_value(self):
        """
        Test that passing no value to create_client is not valid
        """
        with self.assertRaises(TypeError):
            mqlight.Client()

    def test_create_client_callback_must_be_function(self):
        """
        Test that only a function() is accepted as the callback argument
        """
        with self.assertRaises(TypeError):
            mqlight.Client('amqp://host:1234', callback=1)

    def test_create_client_must_have_service_value(self):
        """
        Test that omitting the 'service' property from createClient causes an
        error
        """
        with self.assertRaises(TypeError):
            mqlight.Client(
                client_id='test_create_client_must_have_service_value')

    def test_id_types_values(self):
        """
        Test a range of types / values for client IDs
        """
        data = [
            { 'data': 1234, 'valid': True },
            { 'data': None, 'valid': True },
            { 'data': True, 'valid': True },
            { 'data': 'abc1234', 'valid': True },
            { 'data': ':1234', 'valid': False },
            { 'data': '1234:', 'valid': False },
            { 'data': '12:34', 'valid': False },
            { 'data': '%./_', 'valid': True },
            { 'data': '&.\_', 'valid': False }
        ]
        for i in data:
            try:
                client = mqlight.Client('amqp://localhost:5672', i['data'])
                self.assertTrue(i['valid'], i['data'])
                client.stop()
            except Exception:
                self.assertFalse(i['valid'], i['data'])

    def test_id_autogenerated(self):
        """
        Test that if the 'id' property is omitted then the client id will be
        generated
        """
        client = mqlight.Client('amqp://localhost:5672')
        self.assertNotEqual(
            None,
            re.search(r'^AUTO_[a-z0-9%/._]{7}$', client.get_id()))
        client.stop()

    def test_user_password_types_values(self):
        """
        Test a range of user and password types / values
        """
        data = [
            {'user': 'abc', 'password': None, 'valid': False },
            {'user': None, 'password': 'abc', 'valid': False },
            {'user': 'abc', 'password': '123', 'valid': True },
            {'user': 1234, 'password': 'abc', 'valid': False },
            {'user': 'abc', 'password': 1234, 'valid': False },
            {
                'user': '!"$%^&*()-_=+[{]};:\'@#~|\<,>.?/',
                'password': '!"$%^&*()-_=+[{]};:\'@#~|\<,>.?/',
                'valid': True
            }
        ]
        for i in data:
            security_options = {
                'property_user': i['user'],
                'property_password': i['password']
            }
            try:
                client = mqlight.Client(
                    'amqp://localhost:5672',
                    'id',
                    security_options)
                self.assertTrue(i['valid'], i)
                client.stop()
            except Exception:
                self.assertFalse(i['valid'], i)

    @unittest.expectedFailure
    def test_password_hidden(self):
        """
        Test that a clear text password isn't trivially recoverable from the
        client object
        """
        client = mqlight.Client(
            'amqp://localhost:5672',
            'id',
            { 'property_user': 'username', 'property_password': 's3cret' })
        print str(inspect.getmembers(
                    client,
                    lambda a:not(inspect.isroutine(a))))
        self.assertEqual(
            None,
            re.search(
                r's3cret',
                str(inspect.getmembers(
                    client,
                    lambda a:not(inspect.isroutine(a))))))
        client.stop()

    def test_valid_uris(self):
        """
        Test that the value returned by client.get_service is a lower cased URL
        which always has a port number
        """
        data = [
            { 'uri': 'amqp://host', 'expected': 'amqp://host:5672' },
            { 'uri': 'amqps://host', 'expected': 'amqps://host:5671' },
            { 'uri': 'AmQp://HoSt', 'expected': 'amqp://host:5672' },
            { 'uri': 'aMqPs://hOsT', 'expected': 'amqps://host:5671' },
            { 'uri': 'amqp://host:1234', 'expected': 'amqp://host:1234' },
            { 'uri': 'amqps://host:4321', 'expected': 'amqps://host:4321' },
            { 'uri': 'aMqP://HoSt:1234', 'expected': 'amqp://host:1234' },
            { 'uri': 'AmQpS://hOsT:4321', 'expected': 'amqps://host:4321' }
        ]
        count = 0
        for i in data:
            count += 1
            client = mqlight.Client(i['uri'])
            def started(err):
                self.assertEqual(client.get_service(), i['expected'])
            client.add_listener(mqlight.STARTED, started)
        self.assertEqual(count, len(data))

    def test_bad_ssl_options(self):
        """
        Test that bad ssl options cause Client to fail
        """
        data = [
            { 'ssl_trust_certificate': 1, 'ssl_verify_name': True },
            { 'ssl_trust_certificate': { 'a': 1 }, 'ssl_verify_name': True },
            { 'ssl_trust_certificate': True, 'ssl_verify_name': True },
            {
                'ssl_trust_certificate': 'ValidCertificate',
                'ssl_verify_name': 'a'
            },
            {
                'ssl_trust_certificate': 'ValidCertificate',
                'ssl_verify_name': '1'
            },
            {
                'ssl_trust_certificate': 'ValidCertificate',
                'ssl_verify_name': { 'a': 1 }
            },
            {
                'ssl_trust_certificate': 'MissingCertificate',
                'ssl_verify_name': True
            },
            {
                'ssl_trust_certificate': 'dirCertificate',
                'ssl_verify_name': True
            }
        ]
        if not os.path.exists('dirCertificate'):
            os.makedirs('dirCertificate')
        for i in range(len(data)):
            print 'testing '
            print data[i]
            with self.assertRaises(Exception) as err:
                service = 'amqp://host'
                client_id = 'test_bad_ssl_options'
                security_options = data[i]
                mqlight.Client(service, client_id, security_options)
            err_type = type(err.exception)
            self.assertTrue(
                err_type in (
                    TypeError,
                    mqlexc.SecurityError,
                    mqlexc.InvalidArgumentError),
                    'errtype is ' + str(err_type))
        if os.path.exists('dirCertificate'):
            os.rmdir('dirCertificate')

    def test_valid_ssl_options(self):
        """
        Test that the ssl options for valid certificates cause start to be
        successful
        """
        data = [
            {
                'ssl_trust_certificate': 'ValidCertificate',
                'ssl_verify_name': True
            },
            {
                'ssl_trust_certificate': 'ValidCertificate',
                'ssl_verify_name': True
            },
            {
                'ssl_trust_certificate': 'BadVerify',
                'ssl_verify_name': False
            }
        ]
        valid_certificate_fd = open('ValidCertificate', 'w')
        bad_verify_fd = open('BadVerify', 'w')
        self.count = 0
        def valid_ssl_test(ssl_trust_certificate, ssl_verify_name):
            service = 'amqp://host'
            client_id = 'test_valid_ssl_options'
            security_options = {
                'ssl_trust_certificate': ssl_trust_certificate,
                'ssl_verify_name': ssl_verify_name
            }
            client = mqlight.Client(service, client_id, security_options)
            def error(err):
                client.stop()
                self.assertTrue(False, 'unexpected error event: ' + str(err))
                valid_certificate_fd.close()
                os.remove('ValidCertificate')
                bad_verify_fd.close()
                os.remove('BadVerify')
            client.add_listener(mqlight.ERROR, error)
            def start(err):
                self.assertEqual(err, None)
                client.stop()
                self.count += 1
                if self.count == len(data):
                    valid_certificate_fd.close()
                    os.remove('ValidCertificate')
                    bad_verify_fd.close()
                    os.remove('BadVerify')
                else:
                    valid_ssl_test(
                        data[self.count]['ssl_trust_certificate'],
                        data[self.count]['ssl_verify_name'])

            client.start(start)

        valid_ssl_test(
            data[self.count]['ssl_trust_certificate'],
            data[self.count]['ssl_verify_name'])

    def test_invalid_ssl_options(self):
        """
        Test that the ssl options for invalid certificates cause start to fail
        """
        data = [
            {
                'ssl_trust_certificate': 'BadCertificate',
                'ssl_verify_name': True
            },
            {
                'ssl_trust_certificate': 'BadCertificate',
                'ssl_verify_name': False
            },
            {
                'ssl_trust_certificate': 'BadVerify2',
                'ssl_verify_name': True
            }
        ]
        bad_certificate_fd = open('BadCertificate', 'w+')
        bad_verify_fd = open('BadVerify2', 'w+')
        self.count = 0
        def valid_ssl_test(ssl_trust_certificate, ssl_verify_name):
            service = 'amqp://host'
            client_id = 'test_invalid_ssl_options'
            security_options = {
                'ssl_trust_certificate': ssl_trust_certificate,
                'ssl_verify_name': ssl_verify_name
            }
            client = mqlight.Client(service, client_id, security_options)
            def error(err):
                self.assertTrue(True)
                client.stop()
                self.count += 1
                if self.count == len(data):
                    bad_certificate_fd.close()
                    os.remove('BadCertificate')
                    bad_verify_fd.close()
                    os.remove('BadVerify2')
                else:
                    valid_ssl_test(
                        data[self.count]['ssl_trust_certificate'],
                        data[self.count]['ssl_verify_name'])
            client.add_listener(mqlight.ERROR, error)
            def started(err):
                client.stop()
                self.assertTrue(
                    False,
                    'unexpected started event' + str(security_options))
                bad_certificate_fd.close()
                os.remove('BadCertificate')
                bad_verify_fd.close()
                os.remove('BadVerify2')
            client.add_listener(mqlight.STARTED, started)

        valid_ssl_test(
            data[self.count]['ssl_trust_certificate'],
            data[self.count]['ssl_verify_name'])

    def test_create_client_multiple_with_same_id(self):
        """
        Test that, calling Client a second time with the same id is
        successful, replacing (invalidating) the previous instance.
        """
        opts_a = { 'service': 'amqp://localhost', 'id': 'Aname' }
        opts_b = { 'service': 'amqp://localhost', 'id': 'Bname' }

        client_a = mqlight.Client(opts_a['service'], opts_a['id'])
        def client_a_start(err):
            client_b1 = mqlight.Client(opts_b['service'], opts_b['id'])
            self.client_b1_stopped = False
            def client_b1_stop(err):
                self.assertEqual(None, err)
                self.client_b1_stopped = True
            client_b1.add_listener(mqlight.STOPPED, client_b1_stop)
            self.first_time = True
            def client_b1_start(err):
                if not self.first_time:
                    return
                self.first_time = False
                self.assertEqual(None, err)
                client_b2 = mqlight.Client(opts_b['service'], opts_b['id'])
                def client_b2_start(err):
                    self.assertEqual(None, err)
                    self.assertTrue(self.client_b1_stopped)
                    self.assertEqual(mqlight.STARTED, client_a.get_state())
                    self.assertEqual(mqlight.STOPPED, client_b1.get_state())
                    self.assertEqual(mqlight.STARTED, client_b2.get_state())

                    def client_b1_start_callback(err):
                        self.assertEqual(None, err)
                        self.assertEqual(mqlight.STARTED, client_a.get_state())
                        self.assertEqual(mqlight.STARTED, client_b1.get_state())
                        self.assertEqual(mqlight.STOPPED, client_b2.get_state())

                        def client_a_stop_callback(err):
                            def client_b1_stop_callback(err):
                                self.assertTrue(True)
                            client_b1.stop(client_b1_stop_callback)
                        client_a.stop(client_a_stop_callback)
                    client_b1.start(client_b1_start_callback)

                client_b2.add_listener(mqlight.STARTED, client_b2_start)
                def client_b1_error(err):
                    self.assertTrue(
                        'ReplacedError' in str(type(err)),
                        'expected a ReplacedError')
                client_b1.add_listener(mqlight.ERROR, client_b1_error)
                def client_b2_error(err):
                    self.assertTrue(
                        'ReplacedError' in str(type(err)),
                        'expected a ReplacedError')
                client_b2.add_listener(mqlight.ERROR, client_b2_error)
            client_b1.add_listener(mqlight.STARTED, client_b1_start)
        client_a.add_listener(mqlight.STARTED, client_a_start)


if __name__ == 'main':
    unittest.main()
